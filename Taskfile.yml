# yaml-language-server: $schema=https://taskfile.dev/schema.json

version: '3'
set: [errexit, nounset, pipefail]

env:
  GIT_SHA:
    sh: git rev-parse --short HEAD
  GIT_SHA_LONG:
    sh: git rev-parse HEAD
  GIT_BRANCH:
    sh: git rev-parse --abbrev-ref HEAD
  GIT_BRANCH_CLEAN:
    sh: git rev-parse --abbrev-ref HEAD | tr '/' '-'
  GIT_TAG:
    sh: git describe --tags --exact-match 2>/dev/null || true

tasks:
  info:
    desc: Display git environment variables
    silent: true
    cmd: |
      cat <<EOT
      Git Information:
        SHA (short):    {{.GIT_SHA}}
        SHA (long):     {{.GIT_SHA_LONG}}
        Branch:         {{.GIT_BRANCH}}
        Branch (clean): {{.GIT_BRANCH_CLEAN}}
        Tag:            {{.GIT_TAG}}
      EOT

  check:
    desc: Run all checks (lint, fmt, test)
    cmds:
      - task: lint
      - task: fmt
      - task: test
      - task: git

  lint:
    desc: Run linters
    cmds:
      - task: lint:golangci-lint

  fmt:
    desc: Run code formatters
    cmds:
      - task: fmt:golangci-lint

  test:
    desc: Run tests
    cmds:
      - task: go:test
      - task: integration

  git:
    vars:
      git_status:
        sh: git status --porcelain
    desc: Verify if git working tree is clean
    silent: true
    cmds:
    - test -z "{{.git_status}}" || (echo -e "Git working tree is not clean:\n\n{{.git_status}}\n\nPlease commit or stash your changes." && exit 1)

  lint:golangci-lint:
    desc: Run golangci-lint
    silent: true
    cmds:
    - mkdir -p $(go env GOCACHE) $(go env GOMODCACHE) ~/.cache/golangci-lint
    - |
      docker run --rm -t -v $(pwd):/app -w /app \
      --user $(id -u):$(id -g) \
      -v ~/.cache/golangci-lint:/.cache -e GOLANGCI_LINT_CACHE=/.cache/golangci-lint \
      -v $(go env GOCACHE):/.cache/go-build -e GOCACHE=/.cache/go-build \
      -v $(go env GOMODCACHE):/.cache/mod -e GOMODCACHE=/.cache/mod \
      golangci/golangci-lint:v2.7.2 golangci-lint run

  fmt:golangci-lint:
    desc: Run gofmt via golangci-lint
    silent: true
    cmds:
    - mkdir -p $(go env GOCACHE) $(go env GOMODCACHE) ~/.cache/golangci-lint
    - |
      docker run --rm -t -v $(pwd):/app -w /app \
      --user $(id -u):$(id -g) \
      -v ~/.cache/golangci-lint:/.cache -e GOLANGCI_LINT_CACHE=/.cache/golangci-lint \
      -v $(go env GOCACHE):/.cache/go-build -e GOCACHE=/.cache/go-build \
      -v $(go env GOMODCACHE):/.cache/mod -e GOMODCACHE=/.cache/mod \
      golangci/golangci-lint:v2.7.2 golangci-lint fmt

  go:test:
    desc: Run go tests
    cmds:
    - go test -v ./...

  integration:
    desc: Run all integration tests
    vars:
      imap_commands:
        sh: find hack/imap-scripts/ -type f ! -name '*.*' | xargs -n1 basename
    cmds:
    - for:
        var: imap_commands
        split: "\n"
      task: integration:imap:cmd:{{.ITEM}}

  integration:dependencies:
    desc: Set up dependencies for integration tests
    cmds:
    - docker compose up --wait

  integration:imap:cmd:*:
    desc: Run IMAP integration tests
    deps:
    - task: integration:dependencies
    vars:
      imap_command: "{{index .MATCH 0}}"
    cmds:
    # purge all mailboxes of the user from both dovecots
    - docker compose exec dovecot-a rm -rf /srv/vmail/{{.imap_command}}
    - docker compose exec dovecot-b rm -rf /srv/vmail/{{.imap_command}}
    # TODO check metrics and wait until queue is empty instead of sleeping -- we don't want to have the delete command replicated while already running imaptest
    - sleep 2
    # run imaptest against dovecot-a, which will create mailbox and possibly some mails
    - docker compose exec dovecot-test imaptest user={{.imap_command}} pass=secret host=dovecot-a port=31143 test=/opt/imap-scripts/{{.imap_command}}
    # TODO check metrics and wait until queue is empty instead of sleeping
    - sleep 2
    # check if user was created to see if sync was executed (doveadm mailbox list would already create the user)
    - docker compose exec dovecot-b test -d /srv/vmail/{{.imap_command}} || (echo "User {{.imap_command}} was not created on dovecot-b, sync did not happen" && exit 1)
