# yaml-language-server: $schema=https://taskfile.dev/schema.json

version: '3'
set: [errexit, nounset, pipefail]

env:
  GIT_SHA:
    sh: git rev-parse --short HEAD
  GIT_SHA_LONG:
    sh: git rev-parse HEAD
  GIT_BRANCH:
    sh: git rev-parse --abbrev-ref HEAD
  GIT_BRANCH_CLEAN:
    sh: git rev-parse --abbrev-ref HEAD | tr '/' '-'
  GIT_TAG:
    sh: git describe --tags --exact-match 2>/dev/null || true
  GIT_VERSION:
    sh: |
      # Check if current commit is tagged
      if git describe --tags --exact-match 2>/dev/null >/dev/null; then
        # Use the tag as-is
        git describe --tags --exact-match
      else
        # Get the most recent tag on this branch
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
        
        # Parse version components (handle both vX.Y.Z and X.Y.Z formats)
        MAJOR=$(echo "$LATEST_TAG" | cut -d. -f1)
        MINOR=$(echo "$LATEST_TAG" | cut -d. -f2)
        PATCH=$(echo "$LATEST_TAG" | cut -d. -f3 | cut -d- -f1)
        
        # Increment patch version
        NEXT_PATCH=$((PATCH + 1))
        
        # Get branch name and short SHA
        BRANCH=$(git rev-parse --abbrev-ref HEAD | tr '/' '-')
        SHA=$(git rev-parse --short HEAD)
        
        # Build semver-compatible version string
        echo "${MAJOR}.${MINOR}.${NEXT_PATCH}-${BRANCH}-${SHA}"
      fi
  EXTERNAL_DOVEWARDEN: "false"

tasks:
  info:
    desc: Display git environment variables
    silent: true
    cmd: |
      cat <<EOT
      Git Information:
        SHA (short):    {{.GIT_SHA}}
        SHA (long):     {{.GIT_SHA_LONG}}
        Branch:         {{.GIT_BRANCH}}
        Branch (clean): {{.GIT_BRANCH_CLEAN}}
        Tag:            {{.GIT_TAG}}
        Version:        {{.GIT_VERSION}}
      EOT

  check:
    desc: Run all checks (lint, fmt, test)
    cmds:
      - task: lint
      - task: fmt
      - task: test
      - task: git

  lint:
    desc: Run linters
    cmds:
      - task: lint:golangci-lint
      - task: lint:helm

  fmt:
    desc: Run code formatters
    cmds:
      - task: fmt:golangci-lint

  test:
    desc: Run tests
    cmds:
      - task: go:test
      - task: integration

  git:
    vars:
      git_status:
        sh: git status --porcelain
    desc: Verify if git working tree is clean
    silent: true
    cmds:
    - test -z "{{.git_status}}" || (echo -e "Git working tree is not clean:\n\n{{.git_status}}\n\nPlease commit or stash your changes." && exit 1)

  lint:golangci-lint:
    desc: Run golangci-lint
    sources:
    - go.mod
    - go.sum
    - "**/*.go"
    - .golangci.yml
    silent: true
    cmds:
    - mkdir -p $(go env GOCACHE) $(go env GOMODCACHE) ~/.cache/golangci-lint
    - |
      docker run --rm -t -v $(pwd):/app -w /app \
      --user $(id -u):$(id -g) \
      -v ~/.cache/golangci-lint:/.cache -e GOLANGCI_LINT_CACHE=/.cache/golangci-lint \
      -v $(go env GOCACHE):/.cache/go-build -e GOCACHE=/.cache/go-build \
      -v $(go env GOMODCACHE):/.cache/mod -e GOMODCACHE=/.cache/mod \
      golangci/golangci-lint:v2.7.2 golangci-lint run

  fmt:golangci-lint:
    desc: Run gofmt via golangci-lint
    sources:
    - go.mod
    - go.sum
    - "**/*.go"
    - .golangci.yml
    silent: true
    cmds:
    - mkdir -p $(go env GOCACHE) $(go env GOMODCACHE) ~/.cache/golangci-lint
    - |
      docker run --rm -t -v $(pwd):/app -w /app \
      --user $(id -u):$(id -g) \
      -v ~/.cache/golangci-lint:/.cache -e GOLANGCI_LINT_CACHE=/.cache/golangci-lint \
      -v $(go env GOCACHE):/.cache/go-build -e GOCACHE=/.cache/go-build \
      -v $(go env GOMODCACHE):/.cache/mod -e GOMODCACHE=/.cache/mod \
      golangci/golangci-lint:v2.7.2 golangci-lint fmt

  go:test:
    desc: Run go tests
    sources:
    - go.mod
    - go.sum
    - "**/*.go"
    - fixtures/**
    cmds:
    - go test -v ./...

  docker:build:
    desc: Build Docker image
    cmds:
      - |
        docker build \
          --build-arg GIT_SHA={{.GIT_SHA}} \
          --build-arg GIT_BRANCH={{.GIT_BRANCH}} \
          --build-arg GIT_TAG={{.GIT_TAG}} \
          --build-arg GIT_VERSION={{.GIT_VERSION}} \
          -t ghcr.io/dovewarden/dovewarden:{{.GIT_VERSION}} \
          .

  lint:helm:
    desc: Lint Helm chart
    sources:
      - helm/dovewarden/**
    cmds:
      - helm lint helm/dovewarden

  helm:package:
    desc: Package Helm chart as OCI bundle
    deps:
      - lint:helm
    sources:
      - helm/dovewarden/**
    generates:
      - dovewarden-{{.GIT_VERSION}}.tgz
    cmd: helm package --app-version "{{.GIT_VERSION}}" --version "{{.GIT_VERSION}}" helm/dovewarden

  helm:push:
    desc: Push Helm chart to OCI registry (ghcr.io)
    deps:
      - helm:package
    cmds:
      - |
        helm push dovewarden-${GIT_VERSION}.tgz oci://ghcr.io/dovewarden
        rm -f dovewarden-${GIT_VERSION}.tgz

  docker:tag:
    desc: Tag Docker image with a release tag
    deps:
    - task: docker:build
    - task: check
    cmd: docker tag ghcr.io/dovewarden/dovewarden:latest ghcr.io/dovewarden/dovewarden:{{.GIT_VERSION}}

  docker:push:
    desc: Push Docker image to ghcr.io
    deps:
      - docker:tag
    cmds:
      - docker push ghcr.io/dovewarden/dovewarden:{{.GIT_VERSION}}

  release:
    desc: Release both Docker image and Helm chart
    deps:
      - docker:push
      - helm:push
    cmds:
      - echo "Released dovewarden {{.GIT_VERSION}}"

  integration:
    desc: Run all integration tests
    vars:
      imap_commands:
        sh: find hack/imap-scripts/ -type f ! -name '*.*' | xargs -n1 basename
    cmds:
    - for:
        var: imap_commands
        split: "\n"
      task: integration:imap:cmd:{{.ITEM}}

  integration:dependencies:
    desc: Set up dependencies for integration tests
    deps:
    - task: integration:dependencies:dovecot
    - task: integration:dependencies:dovewarden

  integration:dependencies:dovecot:
    desc: Set up dependencies for integration tests
    cmds:
    - docker compose up --wait dovecot-a dovecot-b dovecot-test

  integration:dependencies:dovewarden:
    desc: Set up dependencies for integration tests
    status:
    # only run if dovewarden is not already running, eg. from development environment
    - curl --silent --fail http://localhost:9090/metrics | grep dovewarden
    cmds:
    - docker compose up --wait dovewarden

  integration:imap:cmd:*:
    desc: Run IMAP integration tests
    sources:
    - go.mod
    - go.sum
    - docker-compose.yaml
    - Dockerfile
    - "**/*.go"
    - hack/**
    deps:
    - task: integration:dependencies
    vars:
      imap_command: "{{index .MATCH 0}}"
    cmds:
    # purge all mailboxes of the user from both dovecots
    - docker compose exec dovecot-a rm -rf /srv/vmail/{{.imap_command}}
    - docker compose exec dovecot-b rm -rf /srv/vmail/{{.imap_command}}
    # TODO check metrics and wait until queue is empty instead of sleeping -- we don't want to have the delete command replicated while already running imaptest
    - sleep 2
    # run imaptest against dovecot-a, which will create mailbox and possibly some mails
    - docker compose exec dovecot-test imaptest user={{.imap_command}} pass=secret host=dovecot-a port=31143 test=/opt/imap-scripts/{{.imap_command}}
    # TODO check metrics and wait until queue is empty instead of sleeping
    - sleep 2
    # check if user was created to see if sync was executed (doveadm mailbox list would already create the user)
    - docker compose exec dovecot-b test -d /srv/vmail/{{.imap_command}} || (echo "User {{.imap_command}} was not created on dovecot-b, sync did not happen" && exit 1)
